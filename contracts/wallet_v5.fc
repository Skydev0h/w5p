#pragma version =0.4.4;

#include "imports/stdlib.fc";

;; LDUQ: s - x s' -1 or s 0 --NULLROTRIFNOT--> s - x s' -1 or # s 0
;; (int, slice, int) try_load_uint32(slice s) asm "32 LDUQ" "NULLROTRIFNOT";

;; LDUQ: s - x s' -1 or s 0 --IFNOTRET--> x s' or RET
(int, slice) load_uint32_or_ret(slice s) impure asm "32 LDUQ" "IFNOTRET";
(int, slice) load_uint32_or_ret_alt(slice s) impure asm "32 LDUQ" "IFNOTRETALT";
(int, slice) load_uint32_or_exit(slice s) impure asm "32 LDUQ" "0 THROWIFNOT";

() prepare_for_retalt() impure asm "SAMEALT";

{-
  var flags = full_msg_slice~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt ...
  if (flags & 1) {
    ;; ignore all bounced messages
    return ();
  }
-}
() return_if_bounce(int flags) impure asm "1 PUSHINT" "AND" "IFRET";
() ret_alt_if_bounce(int flags) impure asm "1 PUSHINT" "AND" "IFRETALT";
() exit_if_bounce(int flags) impure asm "1 PUSHINT" "AND" "0 THROWIF";

() return_if_not_equal(int a, int b) impure asm "EQUAL" "IFNOTRET";
() return_if_not(int a) impure asm "IFNOTRET";

() ret_alt_if_not_equal(int a, int b) impure asm "EQUAL" "IFNOTRETALT";
() ret_alt_if_not(int a) impure asm "IFNOTRETALT";

(slice) udict_get_or_return(cell dict, int key_len, int index) impure asm(index dict key_len) "DICTUGET IFNOTRET";
(slice) udict_get_or_ret_alt(cell dict, int key_len, int index) impure asm(index dict key_len) "DICTUGET IFNOTRETALT";

forall X -> () consume(X x) impure asm "NOP";

() ret() impure asm "RET";
() ret_alt() impure asm "RETALT";

(int) stack_has_at_least_2_elements() asm "DEPTH" "1 RSHIFT#";
(int) stack_has_at_least_4_elements() asm "DEPTH" "2 RSHIFT#";

;; Extensible wallet contract v5

;; Compresses 8+256-bit address into 256-bit uint by cutting off one bit from sha256.
;; This allows us to save on wrapping the address in a cell and make plugin requests cheaper.
;; This method also unpacks address hash if you pass packed hash with the original wc.
int pack_address(int wc, int hash) impure asm "SWAP INC XOR"; ;; hash ^ (wc+1)

;; Stores pre-computed list of actions (mostly `action_send_msg`) in the actions register.
() set_actions(cell action_list) impure asm "c5 POP";

{-
  ifnot (cs.preload_uint(1)) {
    set_actions(cs.preload_ref());
    return ();
  }
-}
() set_actions_if_simple(slice cs) impure asm "DUP" "1 PLDU" "IFNOTJMP:<{ PLDREF c5 POP RETALT }>" "DROP";

;; Dispatches already authenticated request.
() dispatch_complex_request_inline(int stored_seqno, slice cs, slice immutable_tail, int stored_subwallet, int public_key) impure inline {
  var extensions = null();

  ;; Recurse into extended actions until we reach standard actions
  while (cs~load_uint(1)) {
    int op = cs~load_uint(32);

    ;; Raw set_data
    if (op == 0x1ff8ea0b) {
      set_data(cs~load_ref());
    }

    ;; Add/remove extensions
    if ((op == 0x1c40db9f) | (op == 0x5eaef4a4)) {
      (int wc, int hash) = parse_std_addr(cs~load_msg_addr());
      int packed_addr = pack_address(wc, hash);

      ifnot (immutable_tail.null?()) {
        ;; immutable_tail = immutable_tail.skip_bits(80 + 256);
        extensions = immutable_tail.skip_bits(80 + 256).preload_dict();
        ;; ds.end_parse() NO MORE guarantees that there is no more data in immutable_tail
        ;; immutable_tail~skip_bits(immutable_tail.slice_bits()); ;; more resiliency in case of extraneous data
        immutable_tail = null();
      }

      ;; Add extension
      if (op == 0x1c40db9f) {
        (extensions, int success?) = extensions.udict_add_builder?(256, packed_addr, begin_cell().store_int(wc,8));
        throw_unless(39, success?);
      }
      ;; Remove extension
      if (op == 0x5eaef4a4) {
        (extensions, int success?) = extensions.udict_delete?(256, packed_addr);
        throw_unless(40, success?);
      }

      set_data(begin_cell()
              .store_uint(stored_seqno, 32)
              .store_uint(stored_subwallet, 80)
              .store_uint(public_key, 256)
              .store_dict(extensions)
              .end_cell());
    }

    ;; Other actions are no-op
    ;; FIXME: is it costlier to check for unsupported actions and throw?
    cs = cs.preload_ref().begin_parse();
  }
  ;; At this point we are at `action_list_basic$0 {n:#} actions:^(OutList n) = ActionList n 0;`
  ;; Simply set the C5 register with all pre-computed actions:
  set_actions(cs.preload_ref());
  return ();
}

() dispatch_complex_request_iref(int stored_seqno, slice cs, slice immutable_tail, int stored_subwallet, int public_key) impure inline_ref {
  ;; this function is explicitly included as an inline reference - not completely inlined
  ;; completely inlining it causes undesirable code split and noticeable gas increase in some paths
  dispatch_complex_request_inline(stored_seqno, cs, immutable_tail, stored_subwallet, public_key);
}

() dispatch_request(int public_key, slice cs, slice immutable_tail, int stored_subwallet, int stored_seqno) impure inline {
  set_actions_if_simple(cs); ;; <- ifnot (cs.preload_uint(1)) { set_actions(cs.preload_ref()); return (); }
  ;; <<<<<<<<<<---------- CONTEST TEST CUTOFF POINT ---------->>>>>>>>>>
  ;; inline_ref required because otherwise it will produce undesirable JMPREF
  dispatch_complex_request_iref(stored_seqno, cs, immutable_tail, stored_subwallet, public_key);
}

() dispatch_extension_request_2(slice cs) impure inline_ref {
  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  var immutable_tail = ds; ;; stored_subwallet ~ public_key ~ extensions
  var stored_subwallet = ds~load_uint(80);
  var public_key = ds.preload_uint(256);
  ;; Note: If after modifications code becomes so large it undesirably splits to cells,
  ;;       replace with dispatch_complex_request_iref. This won't affect test cases but will affect GGC slightly.
  dispatch_complex_request_inline(stored_seqno, cs, immutable_tail, stored_subwallet, public_key);
}

() dispatch_extension_request(slice cs, var dummy1, var dummy2) impure inline {
  set_actions_if_simple(cs); ;; <- ifnot (cs.preload_uint(1)) { set_actions(cs.preload_ref()); return (); }
  ;; <<<<<<<<<<---------- CONTEST TEST CUTOFF POINT ---------->>>>>>>>>>
  ;;
  dummy1~impure_touch(); ;; DROP merged to 2DROP!
  dummy2~impure_touch(); ;; Thats 3 BLKDROP now!
  dispatch_extension_request_2(cs);
}

;; Verifies signed request, prevents replays and proceeds with `dispatch_request`.
() process_signed_request(slice body, int stored_seqno, slice immutable_tail, int stored_subwallet, int public_key) impure inline {
  ;; The precise order of operations here is VERY important. Any other order results in unneccessary stack shuffles.

  var signature = body~load_bits(512);
  throw_unless(35, check_signature(slice_hash(body), signature, public_key));

  var cs = body;
  var (subwallet_id, valid_until, msg_seqno) = (cs~load_uint(80), cs~load_uint(32), cs~load_uint(32));

  ;; Only such checking order results in least amount of gas
  throw_unless(34, subwallet_id == stored_subwallet);
  throw_unless(33, msg_seqno == stored_seqno);
  throw_if(36, valid_until <= now());

  accept_message();

  ;; Store and commit the seqno increment to prevent replays even if the subsequent requests fail.
  stored_seqno = stored_seqno + 1;
  set_data(begin_cell()
          .store_uint(stored_seqno, 32)
          .store_slice(immutable_tail) ;; stored_subwallet ~ public_key ~ extensions
          .end_cell());

  commit();

  dispatch_request(public_key, cs, immutable_tail, stored_subwallet, stored_seqno);
}

() process_external_message(slice body) impure inline {
  int auth_kind = body~load_uint(32);

  return_if_not_equal(auth_kind, 0x7369676E); ;; "sign"

  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  var immutable_tail = ds; ;; stored_subwallet ~ public_key ~ extensions
  var stored_subwallet = ds~load_uint(80);
  var public_key = ds.preload_uint(256);
  process_signed_request(body, stored_seqno, immutable_tail, stored_subwallet, public_key);
  return();
}

() process_internal_message(int msg_value, cell full_msg, slice body) impure inline {
  ;; Any attempt to postpone msg_value deletion will result in s2 POP -> SWAP change. No use at all.
  var full_msg_slice = full_msg.begin_parse();

  var flags = full_msg_slice~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt ...
  ;; return_if_bounce(3); <- as a test (since there are no bounce tests) - this works (breaks tests)!
  return_if_bounce(flags); ;; <- if (flags & 1) { return (); }

  (int auth_kind, body) = body.load_uint32_or_ret(); ;; loads uint32 from body or returns if not enough bits right away

  ;; We accept two kinds of authenticated messages:
  ;; - 0x6578746E "extn" authenticated by extension
  ;; - 0x7369676E "sign" authenticated by signature

  ;; IFJMPREF
  if (auth_kind == 0x6578746E) { ;; "extn" authenticated by extension

    var ds = get_data().begin_parse();
    ;; It is not required to read this data here, maybe ext is doing simple transfer where those are not needed
    var extensions = ds.skip_bits(32 + 80 + 256).preload_dict();

    ;; Authenticate extension by its address.
    int packed_sender_addr = pack_address(parse_std_addr(full_msg_slice~load_msg_addr())); ;; no PLDMSGADDR exists
    ;; Note that some random contract may have deposited funds with this prefix,
    ;; so we accept the funds silently instead of throwing an error (wallet v4 does the same).
    var wc = extensions.udict_get_or_return(256, packed_sender_addr); ;; kindof ifnot (success?) { return(); }

    ;; auth_kind and wc are passed into dispatch_extension_request and later are dropped in batch with 3 BLKDROP
    dispatch_extension_request(body, auth_kind, wc); ;; Special route for external address authenticated request
    return ();

  }

  return_if_not_equal(auth_kind, 0x7369676E); ;; "sign" authenticated by signature

  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  var immutable_tail = ds; ;; stored_subwallet ~ public_key ~ extensions
  var stored_subwallet = ds~load_uint(80);
  var public_key = ds.preload_uint(256);

  ;; Process the rest of the slice just like the signed request.
  process_signed_request(body, stored_seqno, immutable_tail, stored_subwallet, public_key);
  return (); ;; Explicit returns escape function faster and const less gas (suddenly!)

}

() offload_extn_processing(slice body, slice full_msg_slice) impure inline {

}

;; Basic entry point for received messages (both external and internal).
;; recv_internal and recv_external are NOT implicitly used anymore!
;; use msg_value or full_msg ONLY if you are sure these are supplied - if is_external = 0! ~ a very thin ice here!

() entry_point_recv(int msg_value, cell full_msg, slice body, int is_external) impure {
  (int auth_kind, body) = body.load_uint32_or_ret();

  ifnot (is_external) { ;; true for internal messages, else false
    ;; this part of code is executed only for internal messages
    var full_msg_slice = full_msg.begin_parse();
    var flags = full_msg_slice~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt ...
    ;; return_if_bounce(3); <- as a test (since there are no bounce tests) - this works (breaks tests)!
    return_if_bounce(flags); ;; <- if (flags & 1) { return (); }

    if (auth_kind == 0x6578746E) { ;; "extn" authenticated by extension

      var ds = get_data().begin_parse();
      ;; It is not required to read this data here, maybe ext is doing simple transfer where those are not needed
      var extensions = ds.skip_bits(32 + 80 + 256).preload_dict();

      ;; Authenticate extension by its address.
      int packed_sender_addr = pack_address(parse_std_addr(full_msg_slice~load_msg_addr())); ;; no PLDMSGADDR exists
      ;; Note that some random contract may have deposited funds with this prefix,
      ;; so we accept the funds silently instead of throwing an error (wallet v4 does the same).
      var wc = extensions.udict_get_or_return(256, packed_sender_addr); ;; kindof ifnot (success?) { return(); }

      ;; auth_kind and wc are passed into dispatch_extension_request and later are dropped in batch with 3 BLKDROP
      dispatch_extension_request(body, auth_kind, wc); ;; Special route for external address authenticated request

      ret();
    }
  }

  return_if_not_equal(auth_kind, 0x7369676E); ;; "sign" authenticated by signature

  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  var immutable_tail = ds; ;; stored_subwallet ~ public_key ~ extensions
  var stored_subwallet = ds~load_uint(80);
  var public_key = ds.preload_uint(256);
  process_signed_request(body, stored_seqno, immutable_tail, stored_subwallet, public_key);

  full_msg.consume();
  msg_value.consume();

  ;; return_if_not_equal(auth_kind, 0x6578746E); ;; "extn" authenticated by extension

  {-
  var ds = get_data().begin_parse();
  ;; It is not required to read this data here, maybe ext is doing simple transfer where those are not needed
  var extensions = ds.skip_bits(32 + 80 + 256).preload_dict();

  ;; Authenticate extension by its address.
  int packed_sender_addr = pack_address(parse_std_addr(full_msg_slice~load_msg_addr())); ;; no PLDMSGADDR exists
  ;; Note that some random contract may have deposited funds with this prefix,
  ;; so we accept the funds silently instead of throwing an error (wallet v4 does the same).
  var wc = extensions.udict_get_or_ret_alt(256, packed_sender_addr); ;; kindof ifnot (success?) { return(); }

  ;; auth_kind and wc are passed into dispatch_extension_request and later are dropped in batch with 3 BLKDROP
  dispatch_extension_request(body, auth_kind, wc); ;; Special route for external address authenticated request
  -}

  ;; ignore_int_params(msg_value, full_msg); ;; does nothing but prevents dropping them which will cause stack underflow

  {-

  ifnot (is_external) { ;; if (is_internal)
    ;; this part of code is executed only for internal messages
    var full_msg_slice = full_msg.begin_parse();
    var flags = full_msg_slice~load_uint(4);  ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool src:MsgAddressInt ...
    ;; return_if_bounce(3); <- as a test (since there are no bounce tests) - this works (breaks tests)!
    return_if_bounce(flags); ;; <- if (flags & 1) { return (); }

    if (auth_kind == 0x6578746E) { ;; "extn" authenticated by extension
      var ds = get_data().begin_parse();
      ;; It is not required to read this data here, maybe ext is doing simple transfer where those are not needed
      var extensions = ds.skip_bits(32 + 80 + 256).preload_dict();

      ;; Authenticate extension by its address.
      int packed_sender_addr = pack_address(parse_std_addr(full_msg_slice~load_msg_addr())); ;; no PLDMSGADDR exists
      ;; Note that some random contract may have deposited funds with this prefix,
      ;; so we accept the funds silently instead of throwing an error (wallet v4 does the same).
      var wc = extensions.udict_get_or_ret_alt(256, packed_sender_addr); ;; kindof ifnot (success?) { return(); }

      ;; auth_kind and wc are passed into dispatch_extension_request and later are dropped in batch with 3 BLKDROP
      dispatch_extension_request(body, auth_kind, wc); ;; Special route for external address authenticated request

      ret_alt();
    }
  }

  return_if_not_equal(auth_kind, 0x7369676E); ;; "sign" authenticated by signature

  var ds = get_data().begin_parse();
  var stored_seqno = ds~load_uint(32);
  var immutable_tail = ds; ;; stored_subwallet ~ public_key ~ extensions
  var stored_subwallet = ds~load_uint(80);
  var public_key = ds.preload_uint(256);
  process_signed_request(body, stored_seqno, immutable_tail, stored_subwallet, public_key);

  ignore_int_params(msg_value, full_msg); ;; does nothing but prevents dropping them which will cause stack underflow
  --}
}

;; Get methods

int seqno() method_id {
  return get_data().begin_parse().preload_uint(32);
}

int get_wallet_id() method_id {
  return get_data().begin_parse().skip_bits(32).preload_uint(80);
}

int get_public_key() method_id {
  var cs = get_data().begin_parse().skip_bits(32 + 80);
  return cs.preload_uint(256);
}

;; Returns raw dictionary (or null if empty) where keys are packed addresses and the `wc` is stored in leafs.
;; User should unpack the address using the same packing function using `wc` to restore the original address.
cell get_extensions() method_id {
  var ds = get_data().begin_parse().skip_bits(32 + 80 + 256);
  return ds~load_dict();
}
